---
title: Regardez les notes
description: Que se passe-t-il lorsque vous choisir des notes differents ?
---


<div class="container">
    <div class="row g-5">
        <div class="col-lg-8">
    <canvas id="osc" width="1024" height="256" style="width:100%;max-width:1024px;border:1px solid #ccc;background:#111;"></canvas>

    <p id="status">Appuyez sur une touche du piano et observez le changement de fréquence.</p>

    <div style="margin-top:24px;">
        
        <div id="pianoContainer" style="display:flex;gap:2px;margin-top:8px;overflow-x:auto;padding:8px;background:#222;border-radius:4px;"></div>
    </div>
</div>

<div class="col-lg-4">
    <h2>Questions</h2>
    <p>Que remarquez-vous concernant la fréquence lorsque vous jouez des notes plus graves et plus aiguës ?</p>
    <p>Appuyez sur la touche La au milieu du clavier. Quelle est sa fréquence ? Appuyez maintenant sur la touche La aiguë. Quelle est sa fréquence ? Essayez maintenant la touche La grave. Que remarquez-vous concernant les fréquences ?</p>
    <p>Que remarquez-vous concernant la distance entre chaque pic sur la forme d'onde ?</p>
</div>

<script>
(() => {
    // DOM elements
    const status = document.getElementById('status');
    const canvas = document.getElementById('osc');
    const ctx = canvas.getContext('2d');

    // Web Audio API nodes
    let audioCtx = null;          // audio context (manages audio playback)
    let analyser = null;          // analyser node (reads real-time audio data)
    let dataArray = null;         // stores frequency/time domain data from analyser
    let rafId = null;             // requestAnimationFrame ID (unused, kept for compatibility)

    let oscillator = null;        // sine wave generator
    let gainNode = null;          // volume control node

    let held = true;              // waveform display is frozen (updates only on note change)

    const INITIAL_AMPLITUDE = 0.5; // fixed amplitude value

    // Resize canvas to match display size (for crisp rendering on high-DPI screens)
    function resizeCanvasToDisplaySize() {
        const dpr = window.devicePixelRatio || 1;
        const width = canvas.clientWidth * dpr;
        const height = canvas.clientHeight * dpr;
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
        }
    }

    // Draw waveform snapshot from analyser data
    function draw() {
        if (!analyser) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        
        // Read current audio waveform data
        analyser.getByteTimeDomainData(dataArray);
        resizeCanvasToDisplaySize();
        const W = canvas.width;
        const H = canvas.height;

        // Clear canvas with black background
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);

        // Draw center line (zero amplitude reference)
        ctx.strokeStyle = '#444';
        ctx.lineWidth = Math.max(1, W / 1024);
        ctx.beginPath();
        ctx.moveTo(0, H / 2);
        ctx.lineTo(W, H / 2);
        ctx.stroke();

        // Draw waveform with gradient colors (blue -> green -> red)
        ctx.lineWidth = Math.max(2, W / 512);
        const gradient = ctx.createLinearGradient(0, 0, W, 0);
        gradient.addColorStop(0, '#00e');
        gradient.addColorStop(0.5, '#0f0');
        gradient.addColorStop(1, '#e00');
        ctx.strokeStyle = gradient;

        // Plot each sample point as a line
        ctx.beginPath();
        const sliceWidth = W / dataArray.length;
        for (let i = 0; i < dataArray.length; i++) {
            const v = dataArray[i] / 128.0;   // normalize 0-255 to 0-2
            const y = (v * H) / 2;            // scale to canvas height
            const x = i * sliceWidth;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Draw peak indicator bar (shows overall volume level)
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const n = (dataArray[i] - 128) / 128;  // center around zero
            sum += n * n;
        }
        const rms = Math.sqrt(sum / dataArray.length);     // RMS = root mean square
        const peakH = Math.min(H / 2, rms * H);
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(W - 6, H / 2 - peakH, 6, peakH * 2);
    }

    // Stop all audio playback and cleanup
    function stop() {
        status.textContent = 'Arrêté.';
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;

        // Stop and disconnect oscillator
        try {
            if (oscillator) {
                oscillator.stop();
                oscillator.disconnect();
            }
        } catch (e) {}

        // Disconnect gain and analyser nodes
        try { if (gainNode) gainNode.disconnect(); } catch (e) {}
        try { if (analyser) analyser.disconnect(); } catch (e) {}

        // Clear references
        oscillator = null;
        gainNode = null;
        analyser = null;
        dataArray = null;

        // Close audio context
        if (audioCtx) {
            try { audioCtx.close(); } catch (e) {}
            audioCtx = null;
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Initialize amplitude to fixed value
    // (amplitude slider removed)

    // ===== PIANO KEYBOARD SETUP =====
    const pianoContainer = document.getElementById('pianoContainer');
    const A4 = 440; // reference pitch in Hz
    
    // Define all 25 notes across 2 octaves (A3 to A5)
    const notes = [
        { name: 'La', semitones: -12, isBlack: false },
        { name: 'La#', semitones: -11, isBlack: true },
        { name: 'Si', semitones: -10, isBlack: false },
        { name: 'Do', semitones: -9, isBlack: false },
        { name: 'Do#', semitones: -8, isBlack: true },
        { name: 'Re', semitones: -7, isBlack: false },
        { name: 'Re#', semitones: -6, isBlack: true },
        { name: 'Mi', semitones: -5, isBlack: false },
        { name: 'Fa', semitones: -4, isBlack: false },
        { name: 'Fa#', semitones: -3, isBlack: true },
        { name: 'Sol', semitones: -2, isBlack: false },
        { name: 'Sol#', semitones: -1, isBlack: true },
        { name: 'La', semitones: 0, isBlack: false },
        { name: 'La#', semitones: 1, isBlack: true },
        { name: 'Si', semitones: 2, isBlack: false },
        { name: 'Do', semitones: 3, isBlack: false },
        { name: 'Do#', semitones: 4, isBlack: true },
        { name: 'Re', semitones: 5, isBlack: false },
        { name: 'Re#', semitones: 6, isBlack: true },
        { name: 'Mi', semitones: 7, isBlack: false },
        { name: 'Fa', semitones: 8, isBlack: false },
        { name: 'Fa#', semitones: 9, isBlack: true },
        { name: 'Sol', semitones: 10, isBlack: false },
        { name: 'Sol#', semitones: 11, isBlack: true },
        { name: 'La', semitones: 12, isBlack: false },
    ];

    // Convert semitone offset to frequency using equal temperament formula
    function noteToFreq(semitones) {
        return A4 * Math.pow(2, semitones / 12);
    }

    // Create a visual piano key button
    function createPianoKey(note) {
        const freq = noteToFreq(note.semitones);
        const key = document.createElement('button');
        key.className = note.isBlack ? 'piano-key-black' : 'piano-key-white';
        key.innerHTML = `${note.name}`;
        
        // Style black and white keys differently
        key.style.cssText = note.isBlack ?
            'width:30px;height:80px;background:#222;color:#fff;border:1px solid #444;border-radius:2px;cursor:pointer;font-size:9px;padding:2px;box-sizing:border-box;position:relative;margin-left:-15px;margin-right:-15px;z-index:10;transition:background 0.1s;' :
            'width:50px;height:120px;background:#fff;border:1px solid #999;border-radius:2px;cursor:pointer;font-size:10px;padding:4px;box-sizing:border-box;transition:background 0.1s;';

        // Play note on mouse down, highlight key
        key.addEventListener('mousedown', () => {
            playNote(freq);
            key.style.background = note.isBlack ? '#444' : '#eee';
        });

        // Restore key color on mouse up
        key.addEventListener('mouseup', () => {
            key.style.background = note.isBlack ? '#222' : '#fff';
        });

        // Restore key color if mouse leaves key while pressed
        key.addEventListener('mouseleave', () => {
            key.style.background = note.isBlack ? '#222' : '#fff';
        });

        return key;
    }

    // Play a note at the given frequency
    async function playNote(freq) {
        // Initialize audio on first note press (requires user gesture)
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Create sine wave oscillator
            oscillator = audioCtx.createOscillator();
            oscillator.type = 'sine';

            // Create volume control
            gainNode = audioCtx.createGain();
            gainNode.gain.value = INITIAL_AMPLITUDE;

            // Create analyser to read audio data for display
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            const bufferLength = analyser.fftSize;
            dataArray = new Uint8Array(bufferLength);

            // Connect audio graph: oscillator -> gain -> analyser -> speakers
            oscillator.connect(gainNode);
            gainNode.connect(analyser);
            analyser.connect(audioCtx.destination);

            // Start oscillator (continuous tone)
            oscillator.start();

            // Some browsers require explicit resume after user gesture
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            
        }
        
        // Update oscillator frequency and apply decay envelope
        if (oscillator) {
            try { 
                oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
                
                // Display current frequency in status message
                status.textContent = `La fréquence: ${freq.toFixed(1)} Hz`;
                
                // Apply decay envelope: fade out over 1.5 seconds
                const now = audioCtx.currentTime;
                const decayTime = 1.5;
                gainNode.gain.cancelScheduledValues(now);                              // cancel any previous schedules
                gainNode.gain.setValueAtTime(INITIAL_AMPLITUDE, now);                  // set initial volume
                gainNode.gain.linearRampToValueAtTime(0, now + decayTime);             // fade to zero over 1.5s
                
                // Draw waveform snapshot after a small delay to ensure fresh audio data
                setTimeout(() => {
                    if (analyser) {
                        analyser.getByteTimeDomainData(dataArray);
                        draw();
                    }
                }, 100); // 50ms delay allows analyser buffer to fill
            } catch (e) {}
        }
    }

    // Create all piano keys and add to page
    notes.forEach(note => {
        pianoContainer.appendChild(createPianoKey(note));
    });
})();
</script>